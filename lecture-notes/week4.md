## Mouse and Position Input

Watch out for coflict in coordinate systems.

In application, if origin is at bottom left, x increases to the right and y increases upwards.

But in physical display devices such as monitors, y=0 starts at top, and y increases in downwards direction.

### Window Coordinates

Window coordinates are measured in pixels. For example, given a 512(w) x 512(h) display:
* (0, 0): top left corner
* (511, 511) or more generally (w-1, h-1): bottom right corner

When getting mouse position, browser provides this in window coordinates.
Need to convert these physical coordinates to application coordinates to use it in WebGL
(generally we're working in clip coordinates, normalized form).

Also need to account for the fact that y direction is reversed.

### Window to Clip Coordinates

(0,h) -> (-1, -1)
(w,0) -> (1, 1)

[Sample conversion code](../experiments/coordinates/coordinates.js)

### Returning Position from Click Event

Canvas specified in HTML file of size `canvas.width` x `canvas.height`.

Returned window coordinates are `event.clientX` and `event.clientY`.

Add a vertex to GPU for each click

```javascript
// keep track of how many verteces have already been sent over to buffer
var index = 0;

canvas.addEventListener('click', function(evt) {

  // assume a buffer has previously been setup to hold verteces
  gl.bindBuffer(gl.ARRAY_BUFFER, vBuffer);

  // compute a new vector t, by transforming window coordinates to clip coordinates
  var t = vec2(-1 + 2*event.clientX/canvas.width,
    -1 + 2*(canvas.height - event.clientY)/canvas.height);

  // calculte offset based on how many verteces have already been sent over
  var offset = sizeof['vec2']*index;

  // buffer has already been setup, send the new vector t over,
  // skipping over the verteces already in the buffer
  gl.bufferSubData(gl.ARRAY_BUFFER, offset, t);

  // update counter
  index++;
});
```

### Window Events

Events can be generated by actions that affect the canvas window such as:

* moving or exposing a window
* resizing a window
* opening a window
* iconifying/deiconifying a window

Events generated b other applications that use the canvas can affect the WebGL canvas.
There are default callbacks for some of these events.

### Reshape Events

Mouse can be used to change size of canvas. In this case, must redraw contents. Options:

* Display same content but change size
* Display more or fewer objects at the same size

Usually want to maintain proportions. For example, window shape may have gone from square to rectangle,
so shapes of the objects are going to change.

### onresize Event

* Size of new canvas available via `window.innerWidth` and `window.innerHeight`
* Use new window size to proportionally change canvas size

For example, to maintain a square display

```javascript
window.onresize = function() {
  var min = innerWidth;
  if (innerHeight < min) {
    min = innerHeight;
  }
  if (min < canvs.width || min < canvas.height) {
    gl.viewport(0, canvas.height-min, min, min);
  }
};
```

### Picking

* Given a point in the canvas, how to map this point back to an object?
* Lack of uniqueness (there could be multiple objects layered on top of each other at that point)
* Forward nature of pipeline
* Difficult to get exact position with a pointing device

#### Picking with Color

* Use `gl.readPixels` to get color at any location in window
* Use color to identify object but note that
  * Multiple objects can have same color
  * Shaded object will display many colors
* Solution: assign unique color to each object and render off-screen
  * Use `gl.readPixels` to get color at mouse location
  * Use table to map this color to an object

#### Picking with Bounding Boxes

This technique does not require extra rendering for each pick.

* Use table of axis-aligned bounding boxes (smallest box that object fits into that's aligned with the axes)
* Map mouse location to object through table

To compute a bounding box: Scan through the list of verteces, get the minimum and maximum in both x and y.
Then can look at any given pixel and determine if its inside or outside the bounding box.

Works most, but not all of the time. Could have a pixel that's inside the bounding box, but outside the shape (eg: triangle in a squre bounding box).

### Homogeneous Coordinates in WebGL

All versions of OpenGL support homogenous coordinates.

Regardless of how vertex data is specified (2, 3, or 4 dimensional),
it's stored in 4D homogenous form.

Defaults: z = 0, w = 1

Recall example from simple triangle

```javascript
var vertices = [-1, -1, 0, 1, 1, -1];

// specify 2 dimensional data and they're floats
gl.vertexAttribPointer( vPosition, 2, gl.FLOAT, false, 0, 0);
```

But in the GPU, each vertex is actually stored as 4 dimensions. Recall vertex shader

```
// Defined as 4 dimensional
attribtue vec4 vPosition;

void main() {
  // IMPORTANT: Output MUST be 4 dimensional!
  gl_Position = vPosition;
}
```

#### Equivalents

Could have vertex shader specify vec2, then generate 4D in code as follows

```
// Now this matches definition passed in from application
attribtue vec2 vPosition;

void main() {
  // Start with 2D vector from application,
  // Then use vec4 construction in GLSL to add default z = 0.0 and w = 1.0
  gl_Position = vec4(vPosition, 0.0, 1.0);
}
```

OR could specify 4D vertices in application

```javascript
var vertices = [
  -1, -1, 0, 1,
  0, 1, 0, 1,
  1, -1, 0, 1
];
```

### GLSL Caveats

#### Automatic Perspective Division

Remember that a perspective division is done automatically!

For example, scale vertees by 0.5 in shader.

Operators are overloaded, but this will do nothing:

```
gl_Position = 0.5 * vPosition;
```

Because overloading multiplies x, y, z AND w.

But this will work, multiply only x, y, z:

```
gl_Position = vec4(0.5*vPosition.xyz, 1.0);
```

#### Points have w = 1

Built in GLSL functions can give misleading results. For example

```
attribute vec4 vPosition;
float d = normalize(vPosition);
```

Probably really want

```
float d = normalize(vPosition.xyz);
```

#### GLSL types are storage types

A `vec4` is neither a column vector, nor a row vector. It can be used either way:

```
vec4 a, b;
mat4 T;

// operator overloading interprets "a" as a row
vec4 c = a * T;

// operator overloadign will interpret "b" as a column
vec4 d = T * b;
```

#### Column major order

* WebGL assumes 4 x 4 matrices are sent as 16 element arrays in _column major order_
* In most programming languages, arrays are stored in _row major order_
* Often have to transpose arrays before sending to shaders

## Geometry 1

Elements of geometry:
* Scalars (real numbers)
* Vectors (directed line segments)
* Points (locations in space)

Objective is to develop mathematical operations among these elements in a coordinate-free manner

Basic primitives:
* Line segments
* Polygons

Geometry is the study of relationships among objects in an n-dimensional space.
In computer graphics, we're interested in objects that exist in three dimensions.

Want a mimimum set of primitives from which we can build more sophisticated objects (scalars, vectors, points).

### Vector

Quantity with two attributes: Direction, Magnitude.

Example: force,velocity, directed line segments

Vectors lack position. Vector spaces insufficient for geometry, need points to fix a location in space.

* Every vector has an inverse (same magniturde but points in opposite direction)
* Every vecor can be multiplied by a scalars (scales length but doesn't change direction)
* Zero vector is defined as zero magnitude and undefined orientation
* Sum of any two vectors is a vector (head to tail axiom)

### Linear Vector Space

* Mathematiccal system for manipulating vectors
* Scalar-vector multiplication: `u = a * v`
* Vector-vector addition: `w = u + v`

Example expression: `v = u + 2w - 3r`

### Point

* Points are location in space
* Doesn't have size or any other geometric properties
* Operations allowed between points and vectors:
  * Point-point subtraction yields a vector
  * Equivalent to point-vector addition

For example, if `P` and `Q` are two points in space, then the vector `v` going from `Q` to `P` is defined by:

```
v = P - Q
```

Also we can say:

```
P = v + Q
```

The distance between the two points is the magnitude of the vector.

### Affine Spaces

* Point plus a vector space
* Operations
  * Vector-vector addition
  * Scalar-vector multiplication
  * Point-vector addition
  * Scalar-scalar operations

For any point define
  * 1 x P = P
  * 0 x P = 0 (zero vector)

### Lines

Consider all points of the form:

`Po` is the starting point.

`d` is direction

&alpha; is a scalar

&alpha; * `d` is a scalar times a vector, therefore a vector

P(&alpha;) = Po + ad

These are the set of all points that pass through Po in the direction of the vector d

### Parametric Form

P(&alpha;) = Po + ad

This form is known as the _parametric form_ of the line. Extends to curves and surfaces.

Two dimensional forms:
* Explicit: `y = mx + h`
* Implicit: `ax + by + c = 0`
* Parametric:
  * x(&alpha;) = &alpha; * xo + (1-&alpha;) * x1
  * y(&alpha;) = &alpha; * yo + (1-&alpha;) * y1

### Rays and Line Segments

If &alpha; >= 0, then P(&alpha;) is the _ray_ leaving Po in the direction `d`

Recall that difference between two points is a vector.

If we use two points `Q` (from) and `P` (to) to define `v`, then

P(&alpha;) = Q + &alpha;(R-Q) = Q + &alpha;v
= &alpha;R + (1-&alpha;)Q

For 0 <= &alpha; <= 1, we get all the points on the _line segment_ joining `R` and `Q`.

### Convexity

An object is convex iff for any two points in the object, all points on the line segment between these points are also in the object.

A _convex hull_ is the smallest convect object containing points P1, P2, ..., Pn

Formed by "shrink wrapping" ppoints

### Curves and Surfaces

Curves are on parameter entities of the form P(&alpha;) where the function is nonlinear

Surfaces are formed from two-parameter functions P(&alpha; &beta;)

Linear functions give pllanes and polygons.

### Planes and Triangles

A plane can be defined by a point `R` and two vectors `u` and `v`, or by three points `R`, `Q`, `P`

P(&alpha;, &beta;) = R + &alpha;u + &beta;v

P(&alpha;, &beta;) = R + &alpha;(Q-R) + &beta;(P-Q)

Three points also define a triangle. As long as &alpha; and &beta; are between 0 and 1 for some point T(&alpha; &beta;),
then it is located inside the triangle.

### Normals

In 3D spaces, everyplane has a vector `n` perpendiculr or orthogonal to it called the _normal vector_

From the two-point vector form:

P(&alpha;, &beta;) = P + &alpha;u + &beta;v

we can use the cross product to find:

n = u x v

and the equivalent form (dot product):

(P(&alpha;, &beta;) - P) * n = 0
