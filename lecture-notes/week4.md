## Mouse and Position Input

Watch out for coflict in coordinate systems.

In application, if origin is at bottom left, x increases to the right and y increases upwards.

But in physical display devices such as monitors, y=0 starts at top, and y increases in downwards direction.

### Window Coordinates

Window coordinates are measured in pixels. For example, given a 512(w) x 512(h) display:
* (0, 0): top left corner
* (511, 511) or more generally (w-1, h-1): bottom right corner

When getting mouse position, browser provides this in window coordinates.
Need to convert these physical coordinates to application coordinates to use it in WebGL
(generally we're working in clip coordinates, normalized form).

Also need to account for the fact that y direction is reversed.

### Window to Clip Coordinates

(0,h) -> (-1, -1)
(w,0) -> (1, 1)

[Sample conversion code](../experiments/coordinates/coordinates.js)

### Returning Position from Click Event

Canvas specified in HTML file of size `canvas.width` x `canvas.height`.

Returned window coordinates are `event.clientX` and `event.clientY`.

Add a vertex to GPU for each click

```javascript
// keep track of how many verteces have already been sent over to buffer
var index = 0;

canvas.addEventListener('click', function(evt) {

  // assume a buffer has previously been setup to hold verteces
  gl.bindBuffer(gl.ARRAY_BUFFER, vBuffer);

  // compute a new vector t, by transforming window coordinates to clip coordinates
  var t = vec2(-1 + 2*event.clientX/canvas.width,
    -1 + 2*(canvas.height - event.clientY)/canvas.height);

  // calculte offset based on how many verteces have already been sent over
  var offset = sizeof['vec2']*index;

  // buffer has already been setup, send the new vector t over,
  // skipping over the verteces already in the buffer
  gl.bufferSubData(gl.ARRAY_BUFFER, offset, t);

  // update counter
  index++;
});
```

### Window Events

Events can be generated by actions that affect the canvas window such as:

* moving or exposing a window
* resizing a window
* opening a window
* iconifying/deiconifying a window

Events generated b other applications that use the canvas can affect the WebGL canvas.
There are default callbacks for some of these events.

### Reshape Events

Mouse can be used to change size of canvas. In this case, must redraw contents. Options:

* Display same content but change size
* Display more or fewer objects at the same size

Usually want to maintain proportions. For example, window shape may have gone from square to rectangle,
so shapes of the objects are going to change.

### onresize Event

* Size of new canvas available via `window.innerWidth` and `window.innerHeight`
* Use new window size to proportionally change canvas size

For example, to maintain a square display

```javascript
window.onresize = function() {
  var min = innerWidth;
  if (innerHeight < min) {
    min = innerHeight;
  }
  if (min < canvs.width || min < canvas.height) {
    gl.viewport(0, canvas.height-min, min, min);
  }
};
```

### Picking

* Given a point in the canvas, how to map this point back to an object?
* Lack of uniqueness (there could be multiple objects layered on top of each other at that point)
* Forward nature of pipeline
* Difficult to get exact position with a pointing device

#### Picking with Color

* Use `gl.readPixels` to get color at any location in window
* Use color to identify object but note that
  * Multiple objects can have same color
  * Shaded object will display many colors
* Solution: assign unique color to each object and render off-screen
  * Use `gl.readPixels` to get color at mouse location
  * Use table to map this color to an object

#### Picking with Bounding Boxes

This technique does not require extra rendering for each pick.

* Use table of axis-aligned bounding boxes (smallest box that object fits into that's aligned with the axes)
* Map mouse location to object through table

To compute a bounding box: Scan through the list of verteces, get the minimum and maximum in both x and y.
Then can look at any given pixel and determine if its inside or outside the bounding box.

Works most, but not all of the time. Could have a pixel that's inside the bounding box, but outside the shape (eg: triangle in a squre bounding box).

### Homogeneous Coordinates in WebGL

All versions of OpenGL support homogenous coordinates.

Regardless of how vertex data is specified (2, 3, or 4 dimensional),
it's stored in 4D homogenous form.

Defaults: z = 0, w = 1

Recall example from simple triangle

```javascript
var vertices = [-1, -1, 0, 1, 1, -1];

// specify 2 dimensional data and they're floats
gl.vertexAttribPointer( vPosition, 2, gl.FLOAT, false, 0, 0);
```

But in the GPU, each vertex is actually stored as 4 dimensions. Recall vertex shader

```
// Defined as 4 dimensional
attribtue vec4 vPosition;

void main() {
  // IMPORTANT: Output MUST be 4 dimensional!
  gl_Position = vPosition;
}
```

#### Equivalents

Could have vertex shader specify vec2, then generate 4D in code as follows

```
// Now this matches definition passed in from application
attribtue vec2 vPosition;

void main() {
  // Start with 2D vector from application,
  // Then use vec4 construction in GLSL to add default z = 0.0 and w = 1.0
  gl_Position = vec4(vPosition, 0.0, 1.0);
}
```

OR could specify 4D vertices in application

```javascript
var vertices = [
  -1, -1, 0, 1,
  0, 1, 0, 1,
  1, -1, 0, 1
];
```

### GLSL Caveats

#### Automatic Perspective Division

Remember that a perspective division is done automatically!

For example, scale vertees by 0.5 in shader.

Operators are overloaded, but this will do nothing:

```
gl_Position = 0.5 * vPosition;
```

Because overloading multiplies x, y, z AND w.

But this will work, multiply only x, y, z:

```
gl_Position = vec4(0.5*vPosition.xyz, 1.0);
```

#### Points have w = 1

Built in GLSL functions can give misleading results. For example

```
attribute vec4 vPosition;
float d = normalize(vPosition);
```

Probably really want

```
float d = normalize(vPosition.xyz);
```

#### GLSL types are storage types

A `vec4` is neither a column vector, nor a row vector. It can be used either way:

```
vec4 a, b;
mat4 T;

// operator overloading interprets "a" as a row
vec4 c = a * T;

// operator overloadign will interpret "b" as a column
vec4 d = T * b;
```

#### Column major order

* WebGL assumes 4 x 4 matrices are sent as 16 element arrays in _column major order_
* In most programming languages, arrays are stored in _row major order_
* Often have to transpose arrays before sending to shaders

## Geometry 1
